/**
 * Mock ZK Proof Provider
 * LEGO #6: For testing and development
 */

import { ethers } from 'ethers';
import {
  IZKProofProvider,
  ZKProofInput,
  ZKProof,
  VerifyProofResult,
} from '../interfaces/IZKProofProvider';

export class MockZKProvider implements IZKProofProvider {
  readonly name = 'mock-zk';

  private availableCircuits = ['price-condition', 'balance-check'];

  // Track generated proofs for verification
  private generatedProofs = new Map<string, ZKProofInput>();

  async generateProof(input: ZKProofInput): Promise<ZKProof> {
    if (!this.availableCircuits.includes(input.circuitId)) {
      throw new Error(`Circuit not found: ${input.circuitId}`);
    }

    // Generate deterministic mock proof from public inputs only
    // SECURITY: Never include privateInputs in proof generation hash
    const proofData = ethers.keccak256(
      ethers.toUtf8Bytes(JSON.stringify(input.publicInputs))
    );

    const proof: ZKProof = {
      proof: proofData,
      publicSignals: Object.values(input.publicInputs as object).map(String),
      circuitId: input.circuitId,
      generatedAt: Date.now(),
    };

    // Store for verification (mock only)
    this.generatedProofs.set(proofData, input);

    return proof;
  }

  async verifyProof(proof: ZKProof): Promise<VerifyProofResult> {
    // In mock mode, verify the proof was generated by us
    const wasGenerated = this.generatedProofs.has(proof.proof);

    return {
      isValid: wasGenerated,
      verifiedAt: Date.now(),
      circuitId: proof.circuitId,
    };
  }

  getCircuits(): string[] {
    return [...this.availableCircuits];
  }

  async healthCheck(): Promise<boolean> {
    return true;
  }

  // Test helpers
  addCircuit(circuitId: string): void {
    if (!this.availableCircuits.includes(circuitId)) {
      this.availableCircuits.push(circuitId);
    }
  }

  clearProofs(): void {
    this.generatedProofs.clear();
  }
}
