{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":6080036032630290574,"abi":{"parameters":[{"name":"transfer_hash","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier","type":{"kind":"field"},"visibility":"public"},{"name":"balance_sufficient","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"sender_address","type":{"kind":"field"},"visibility":"private"},{"name":"recipient_address","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"sender_balance","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"sender_secret","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/9VY247aMBB1gHDf5d57pXyCTbiEN9q+96HtD5jgFFQIVRJe+vVNir2aNVmkbsZoGSmaMJ4cH8/FMbHISUbp9UHeW+lVlrqUXnXNZqfXUrNVpc0GGLoo21JqWkxYGQ+LQr4Nk4QbBnCbAMuls8lEzMeCuYzT8WLlTelkupp5zGNTb7oee64rvIk3X6wWc7pgE1ewYLpwAwlmat1NEGAkXEoMFlcTkec1m6JCzDRFyyThlgHcNnnZTZGtuw0CjIRrtCnahniWNZ5F84X4ZnjUUEV53ZHb3FQweUO+9yYJ3xvA7ZCXvalk6+6AACPhGt1UOgS3KdSxVRedd9H82c/nzXRDDl00bBiLrtQ9FRB1fu+BCZVg78r287GohsW6iLx6hhKJXXBdcp1GKRnMOy0mrEpur+n6Ug9UUaim60sNbQNy3oiVG0lI0abuI65xYKhQ9OagxYSVENfcx+NFL9UfLSYMs5bLCFgiOAnmUX9oKBdYL2W5ZmHjYfk1xBq5VvxoMWEWXvxmNTwsXkeMnwX2gCqIY2azpS3jXgfxzUQ/YNTBfRXcf5T6uwjXInL4eh2JOHZ8HoaHxFkJ54+IDpkD/IjoSP1N+NvfWxEmF56Df4leS/3l5JVEPIyDdNbk4MRiF2RDg5xpPu0Px3SO/TH+h/wzEjzJntrw8GGaN+C5V1J/5jse+sLxN8L/5ey38Z4n/iYbeZvj/UOx2fB488j73X95vwfe6vjx9bjbbYNt6v7gqZLT0PRQanUwWcrftJgwhT8yg09r5FyG4H6krRMW5xKJg8JTjWCTcylpY8q3rvGz8PkxnUs5Zy4lsBGsJzg2wThiLscKv2UGP7dW4P7S0sZUzio5z1lP/C5p+pLvpe94dzljCnOQY/sLbjAGAtYbAAA=","debug_symbols":"ndTNisMgEAfwd/Gcg47feZVlKaZNiiCmJOnCEvrua3fr0lovzs2Z4acgf2Ynp3G4ng8+TvNK+o+dhPnoNj/HVO2E/7bWi4v3at3cspGeSWo7MsbT/Qjm1pHJh5H0mt4+OyLaiWwnqp3oKlGCZqIUFMS0E9tOGEUYVjVa82wMLT+AAcJwhBEIIxGmHgJjZTaWytJohDEIY9sNVHMAlLOHASrfDEMYQBiOMNUcAJMim+RLU80BCP3/jqSsNAphqjkALfICAW3oi0nFsPgQ/PnwvCJT+8st3g1hfJTTNR6fptv35W+SrvgB","file_map":{"70":{"source":"// Private Transfer Circuit\n// Proves: A valid transfer from sender to recipient WITHOUT revealing identities or amount\n//\n// Use Case: Kevin sends to Juan, but observers only see:\n//   - A valid transfer happened\n//   - The transfer hash (for on-chain verification)\n//   - That sender had sufficient balance\n//\n// HIDDEN from observers:\n//   - Who is the sender (Kevin)\n//   - Who is the recipient (Juan)\n//   - The transfer amount\n//\n// Public Inputs:\n//   - transfer_hash: Field (commitment to the transfer, for on-chain tracking)\n//   - nullifier: Field (prevents double-spending, derived from sender+nonce)\n//   - balance_sufficient: u8 (1 if sender has enough balance, 0 otherwise)\n//\n// Private Inputs:\n//   - sender_address: Field (hashed address of sender - NEVER revealed)\n//   - recipient_address: Field (hashed address of recipient - NEVER revealed)\n//   - amount: u64 (transfer amount - NEVER revealed)\n//   - sender_balance: u64 (sender's current balance - NEVER revealed)\n//   - nonce: Field (unique nonce to prevent replay)\n//   - sender_secret: Field (secret key for nullifier generation)\n\nfn main(\n    // Public inputs (visible to everyone)\n    transfer_hash: pub Field,\n    nullifier: pub Field,\n    balance_sufficient: pub u8,\n    // Private inputs (hidden in the proof)\n    sender_address: Field,\n    recipient_address: Field,\n    amount: u64,\n    sender_balance: u64,\n    nonce: Field,\n    sender_secret: Field\n) {\n    // Constraint 1: Sender address must be valid (non-zero)\n    assert(sender_address != 0, \"Sender address cannot be zero\");\n\n    // Constraint 2: Recipient address must be valid (non-zero)\n    assert(recipient_address != 0, \"Recipient address cannot be zero\");\n\n    // Constraint 3: Sender and recipient must be different\n    assert(sender_address != recipient_address, \"Cannot transfer to self\");\n\n    // Constraint 4: Amount must be positive\n    assert(amount > 0, \"Amount must be greater than zero\");\n\n    // Constraint 5: Verify balance check is correct\n    let has_sufficient_balance = sender_balance >= amount;\n    let expected_balance_sufficient: u8 = if has_sufficient_balance { 1 } else { 0 };\n    assert(balance_sufficient == expected_balance_sufficient, \"Balance check mismatch\");\n\n    // Constraint 6: Verify the transfer hash is correctly computed\n    // transfer_hash = hash(sender, recipient, amount, nonce)\n    let computed_hash = compute_transfer_hash(sender_address, recipient_address, amount, nonce);\n    assert(transfer_hash == computed_hash, \"Transfer hash mismatch\");\n\n    // Constraint 7: Verify the nullifier is correctly computed\n    // nullifier = hash(sender_secret, nonce) - prevents double-spending\n    let computed_nullifier = compute_nullifier(sender_secret, nonce);\n    assert(nullifier == computed_nullifier, \"Nullifier mismatch\");\n}\n\n// Compute transfer hash commitment\nfn compute_transfer_hash(sender: Field, recipient: Field, amount: u64, nonce: Field) -> Field {\n    // Simple hash: combine all inputs\n    // In production, use Poseidon or Pedersen hash\n    let amount_field = amount as Field;\n    sender + recipient * 2 + amount_field * 3 + nonce * 5\n}\n\n// Compute nullifier (prevents double-spending)\nfn compute_nullifier(secret: Field, nonce: Field) -> Field {\n    // Simple nullifier: hash(secret, nonce)\n    // In production, use Poseidon hash\n    secret * 7 + nonce * 11\n}\n\n#[test]\nfn test_valid_transfer() {\n    // Kevin (sender) sends 100 to Juan (recipient)\n    let sender_address = 0x1234; // Kevin's hashed address\n    let recipient_address = 0x5678; // Juan's hashed address\n    let amount: u64 = 100;\n    let sender_balance: u64 = 1000;\n    let nonce = 0xABCD;\n    let sender_secret = 0xDEADBEEF12345678;\n\n    let transfer_hash = compute_transfer_hash(sender_address, recipient_address, amount, nonce);\n    let nullifier = compute_nullifier(sender_secret, nonce);\n\n    main(\n        transfer_hash,\n        nullifier,\n        1, // balance_sufficient = true\n        sender_address,\n        recipient_address,\n        amount,\n        sender_balance,\n        nonce,\n        sender_secret\n    );\n}\n\n#[test]\nfn test_insufficient_balance() {\n    // Kevin tries to send more than he has\n    let sender_address = 0x1234;\n    let recipient_address = 0x5678;\n    let amount: u64 = 1000;\n    let sender_balance: u64 = 100; // Only has 100, trying to send 1000\n    let nonce = 0xABCD;\n    let sender_secret = 0xDEADBEEF12345678;\n\n    let transfer_hash = compute_transfer_hash(sender_address, recipient_address, amount, nonce);\n    let nullifier = compute_nullifier(sender_secret, nonce);\n\n    main(\n        transfer_hash,\n        nullifier,\n        0, // balance_sufficient = false\n        sender_address,\n        recipient_address,\n        amount,\n        sender_balance,\n        nonce,\n        sender_secret\n    );\n}\n\n#[test(should_fail_with = \"Cannot transfer to self\")]\nfn test_self_transfer() {\n    // Cannot transfer to yourself\n    let sender_address = 0x1234;\n    let nonce = 0xABCD;\n    let sender_secret = 0xDEADBEEF12345678;\n\n    let transfer_hash = compute_transfer_hash(sender_address, sender_address, 100, nonce);\n    let nullifier = compute_nullifier(sender_secret, nonce);\n\n    main(\n        transfer_hash,\n        nullifier,\n        1,\n        sender_address,\n        sender_address, // Same as sender!\n        100,\n        1000,\n        nonce,\n        sender_secret\n    );\n}\n\n#[test(should_fail_with = \"Amount must be greater than zero\")]\nfn test_zero_amount() {\n    let sender_address = 0x1234;\n    let recipient_address = 0x5678;\n    let nonce = 0xABCD;\n    let sender_secret = 0xDEADBEEF12345678;\n\n    let transfer_hash = compute_transfer_hash(sender_address, recipient_address, 0, nonce);\n    let nullifier = compute_nullifier(sender_secret, nonce);\n\n    main(\n        transfer_hash,\n        nullifier,\n        1,\n        sender_address,\n        recipient_address,\n        0, // Zero amount!\n        1000,\n        nonce,\n        sender_secret\n    );\n}\n\n#[test(should_fail_with = \"Balance check mismatch\")]\nfn test_fake_balance_claim() {\n    // Trying to claim balance is sufficient when it's not\n    let sender_address = 0x1234;\n    let recipient_address = 0x5678;\n    let amount: u64 = 1000;\n    let sender_balance: u64 = 100; // Not enough!\n    let nonce = 0xABCD;\n    let sender_secret = 0xDEADBEEF12345678;\n\n    let transfer_hash = compute_transfer_hash(sender_address, recipient_address, amount, nonce);\n    let nullifier = compute_nullifier(sender_secret, nonce);\n\n    main(\n        transfer_hash,\n        nullifier,\n        1, // Claiming balance is sufficient - LIE!\n        sender_address,\n        recipient_address,\n        amount,\n        sender_balance,\n        nonce,\n        sender_secret\n    );\n}\n","path":"/Users/kevinbrenes/cronos-snowrail/circuits/private_transfer/src/main.nr"}},"names":["main"],"brillig_names":["directive_invert","directive_integer_quotient"]}